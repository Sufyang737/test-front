import { NextResponse } from 'next/server';
import PocketBase from 'pocketbase';
import { headers } from 'next/headers';

const WAHA_API_URL = process.env.NEXT_PUBLIC_WAHA_API_URL;
const POCKETBASE_URL = process.env.NEXT_PUBLIC_POCKETBASE_URL || 'https://ai-agent-database.srv.clostech.tech';
const POCKETBASE_ADMIN_TOKEN = process.env.NEXT_PUBLIC_POCKETBASE_ADMIN_TOKEN;

export async function GET(request: Request, { params }: { params: { chatId: string } }) {
  console.log('üîç Iniciando obtenci√≥n de mensajes...');
  console.log('üì° URL de WAHA:', WAHA_API_URL);
  console.log('üì° URL de PocketBase:', POCKETBASE_URL);
  
  try {
    if (!POCKETBASE_ADMIN_TOKEN) {
      console.error('‚ùå POCKETBASE_ADMIN_TOKEN no est√° definido');
      throw new Error('POCKETBASE_ADMIN_TOKEN no est√° definido');
    }

    // Obtener el clerk_id del header
    const headersList = await headers();
    const clerk_id = await headersList.get('x-clerk-user-id');
    console.log('üë§ Clerk ID del usuario:', clerk_id);

    if (!clerk_id) {
      console.error('‚ùå No se encontr√≥ el clerk_id en los headers');
      throw new Error('No se encontr√≥ el clerk_id en los headers');
    }

    // 1. Obtener el cliente desde PocketBase usando el clerk_id
    console.log('üîÑ Conectando a PocketBase...');
    const pb = new PocketBase(POCKETBASE_URL);
    
    // Autenticar con el token de admin
    pb.authStore.save(POCKETBASE_ADMIN_TOKEN);
    console.log('üîê Autenticado con token de admin');
    
    try {
      const client = await pb.collection('clients').getFirstListItem(`clerk_id = "${clerk_id}"`, {
        fields: 'id,session_id'
      });

      console.log('üì¶ Cliente encontrado:', client);

      if (!client?.session_id) {
        console.error('‚ùå El cliente no tiene session_id');
        throw new Error('El cliente no tiene session_id configurado');
      }

      const { chatId } = params;
      console.log('üí¨ Chat ID:', chatId);

      // 2. Hacer la petici√≥n a WAHA con el session_id y chatId correctos
      const url = `${WAHA_API_URL}/api/${client.session_id}/chats/${chatId}/messages`;
      console.log('üì° Haciendo petici√≥n a WAHA:', url);
      
      const response = await fetch(url);
      console.log('üì• Estado de la respuesta de WAHA:', response.status, response.statusText);
      
      if (!response.ok) {
        console.error('‚ùå Error en la respuesta de WAHA:', response.status, response.statusText);
        throw new Error(`Error al obtener mensajes: ${response.statusText}`);
      }

      const rawData = await response.json();
      console.log('üì¶ Datos crudos recibidos de WAHA:', JSON.stringify(rawData, null, 2));

      // Verificar si rawData es un array
      if (!Array.isArray(rawData)) {
        console.error('‚ùå Los datos recibidos no son un array:', typeof rawData);
        console.error('Datos recibidos:', rawData);
        return NextResponse.json({ error: 'Formato de datos inv√°lido' }, { status: 500 });
      }
      
      // Transformar los datos al formato que espera nuestro frontend
      const messages = rawData.map((message: any) => ({
        id: message.id,
        body: message.body,
        fromMe: message.fromMe,
        timestamp: message.timestamp
      }));

      console.log('‚úÖ Mensajes procesados:', messages.length);
      return NextResponse.json(messages);
    } finally {
      // Limpiar la autenticaci√≥n despu√©s de usarla
      pb.authStore.clear();
    }
  } catch (error) {
    console.error('‚ùå Error en /api/messages/[chatId]:', error);
    console.error('Stack trace:', error instanceof Error ? error.stack : 'No stack trace available');
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Error al obtener mensajes' },
      { status: 500 }
    );
  }
} 